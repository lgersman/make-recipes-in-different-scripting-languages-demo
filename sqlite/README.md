# Makefile using SQLite3 as recipe shell

Sounds strange but ... why not use SQL as recipe ? 

This Makefile is a fully working proof of concept utilizing sqlite3. 

Please note that one of the major features of make - do only execute targets with updated dependencies - are mostly skipped by this proof.

## Prerequisites

- GNU make 

- SQLite3

## Usage

Change to this directory and execute 

- `make` to populate the database 

- `make clean` to clean up the database 

- `rm db.sqlite3` to remove the database file completely

## Example code

The Makefile:

```make
# suppress verbose make output
MAKEFLAGS += --silent

# sqlite database file name
DB := db.sqlite3

# make sqlite the "shell" for make recipes
SHELL = ./sqlite-shell.sh
# empty default shell commandline options to apply for shell invocation
.SHELLFLAGS = sqlite3 $(DB) 
# => from now on every shell invocation by make will be sqlite

# .ONESHELL tells make to execute a target recipe as a single SHELL call
# (by default make would execute a recipe line by line in separate SHELL calls
.ONESHELL:

# et voil√† : recipes can now be written in pure sqlite syntax :-)
all: create insert import
	.print "# target name is '$@', depends on '$^'\n"
	.headers ON
	.mode columns
	SELECT * FROM foo;

import: create data.csv
	.print "# target name is '$@', depends on '$^'\n"
	.separator ;
	.import data.csv data
	INSERT INTO foo(name, familyname) 
		SELECT * FROM data;
	DROP TABLE IF EXISTS data;

insert: create
	INSERT INTO foo 
		(name, familyname) 
	VALUES 
		('Erika', 'Mustermann'),
		('Max', 'Mustermann');

	INSERT INTO foo (name, familyname) VALUES ('John', 'Doe');

create: clean
	CREATE TABLE 
		IF NOT EXISTS 
	foo 
		(id INTEGER PRIMARY KEY AUTOINCREMENT, name STRING, familyname STRING);

clean:
	DROP TABLE IF EXISTS foo;
	DROP TABLE IF EXISTS data;

# tell make that these targets are NOT meant to be files/directories
.PHONY: all create insert import clean import
```

The Shellwrapper file (`sqlite-shell.sh`)

```shell
#!/bin/env bash
# A bash utility script which pipes its last argument to a
# process gained by executing all but its last argument.  Useful in
# Makefiles where you want the recipes to appear on stdin of some
# command other than the usual bash shell.  For example, to write
# recipes in sqlite3 (allowing dot-commands), include the following in your 
# Makefile:
#   SHELL:=sqlite-shell.sh
#   .SHELLFLAGS:=sqlite3 $(DB)
#   .ONESHELL:
# 
# see https://mail.gnu.org/archive/html/help-make/2015-05/msg00017.html
# 
cat <<< "${@:$#}" | "${@:1:$(($# - 1))}"
```

If you run the example by executing `make` in a terminal you will get the following output (SQLite3 version may differ depending on what version you've installed)

```
# target name is 'import', depends on 'create data.csv'

# target name is 'all', depends on 'create insert import'

id          name        familyname
----------  ----------  ----------
1           Erika       Mustermann
2           Max         Mustermann
3           John        Doe       
4           Martina     Musterfrau
5           Susanne     Muster    
6           Maria       Musterfrau
7           Manu        Musterpers
```

# Opinionated tip: use `.RECIPEPREFIX`

make is a impressive but stone age old tool with a long history.

At the time of development (=> some decades ago üòÖ) their authors thought it's a good idea to use `'\t'` as recipe prefix.

The result is one of the most asked questions from `make` novices : 

> When executing my Makefile I get the following error
> 
> ```
> Makefile:xx: *** missing separator.  Stop.
> ```
>
> What does that error mean ? 

## What is the recipe prefix ?

A Makefile consists mostly of targets and their recipes. 

A target is usually a file/directory to be generated by the target recipe. 

An example: 

```make
foo.exe: foo.c
  cc -o foo.exe foo.c
```

The recipe prefix is the prefix starting each recipe line. 

__By default it is `'\t'`.__

And that's often a problem - because depending of the used editor / settings tabs may be converted to spaces. 

If you use spaces instead of tabs you get this mysterious error message : 

```
Makefile:xx: *** missing separator.  Stop.
```

## Solution

A solution to workaround that potential issue is to change the recipe prefix to something different : 

```make
# tell make to use '>' as recipe prefix
.RECIPEPREFIX = >

foo.exe: foo.c
> cc -o foo.exe foo.c
```

Now we have a visible character as recipe prefix which is much less error prone.

_The `.RECIPEPREFIX` directive is available since `make` version 4.0._
